package org.twdata.enchanter;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import ch.ethz.ssh2.Connection;
import ch.ethz.ssh2.Session;

public class GanymedSSH implements SSH {

	private Session sess;
	private PrintWriter out;
	private InputStreamDumper dumper;
	private Thread dumperThread;
	private List<StreamListener> streamListeners = new ArrayList<StreamListener>();
	
	public void setDebug(boolean debug) {
		if (debug) {
			addStreamListener(new StreamListener() {
				public void hasRead(byte[] b, int len) {
					System.out.print(new String(b, 0, len));
				}
				public void hasWritten(byte[] b) {
					// Not usually necessary
					// System.out.print(new String(b));
				}
			});
		}
	}

	public void addStreamListener(StreamListener listener) {
		streamListeners.add(listener);
	}

	public void connect(String host, String username) throws IOException {
		connect(host, 22, username, "");
	}
	
	public void connect(String host, int port, String username, final String password) throws IOException {
		/* Create a connection instance */

		final Connection conn = new Connection(host);

		/* Now connect */

		conn.connect();

		/* Authenticate.
		 * If you get an IOException saying something like
		 * "Authentication method password not supported by the server at this stage."
		 * then please check the FAQ.
		 */

		File home = new File(System.getProperty("user.home"));
		
		boolean isAuthenticated = conn.authenticateWithPublicKey(username, new File(home, ".ssh/id_dsa"), password);

		//if (isAuthenticated == false)
		//w
		//throw new IOException("Authentication failed.");

		/* Create a session */

		sess = conn.openSession();
		
		sess.requestDumbPTY();
		
		out = new PrintWriter(sess.getStdin());
		dumper = new InputStreamDumper(sess.getStdout());
		dumperThread = new Thread(dumper);
		dumperThread.start();
		sess.startShell();
		
	}

	public void send(String text) {
		print(text, false);

	}

	public void sendLine(String text) {
		print(text, true);
	}
	
	private void print(String text, boolean eol) {
		if (eol) {
			out.println(text);
		} else {
			out.print(text);
		}
		byte[] bytes = text.getBytes();
		for (StreamListener listener : streamListeners) {
			listener.hasWritten(bytes);
		}
		out.flush();
	}

	public void sleep(int millis) throws InterruptedException {
		Thread.currentThread().sleep(millis);
	}

	public boolean waitFor(String text) throws InterruptedException {
		return dumper.waitFor(text);
	}

	public int waitForMux(String... text) throws InterruptedException {
		return dumper.waitForMux(text);
	}
	
	public void setTimeout(int timeout) {
		dumper.setTimeout(timeout);
	}
	
	public String lastLine() {
		return dumper.getLastLine();
	}
	
	public String getLine() throws InterruptedException {
		int index = dumper.waitForMux(new String[]{"\n", "\r", "\r\n"});
		if (index > -1) {
			return dumper.getLastLine();
		}
		return null;
	}
	
	public class InputStreamDumper implements Runnable {
		private BufferedInputStream in;
		int[] matchPos;
		String[] waitFor = null;
		int lastMatched = -1;
		boolean alive = true;
		StringBuilder lastLine = new StringBuilder();
		int timeout = 0;
		
		public InputStreamDumper(InputStream in) {
			this.in = new BufferedInputStream(in, 2048);
		}
		
		public synchronized void setTimeout(int timeout) {
			this.timeout = timeout;
		}
		
		public synchronized boolean waitFor(String waitFor) throws InterruptedException {
			prepare(new String[]{waitFor});
			this.wait();
			return (lastMatched == 0);
		}
		
		public synchronized int waitForMux(String[] waitFor) throws InterruptedException {
			prepare(waitFor);
			this.wait();
			return lastMatched;
		}
		
		protected void prepare(String[] text) {
			this.lastMatched = -1;
			this.waitFor = text;
			this.matchPos = new int[waitFor.length];
			this.lastLine.setLength(0);
		}
		
		public synchronized String getLastLine() {
			return this.lastLine.toString();
		}
		
		public void stop() {
			alive = false;
		}

		public void run() {
			byte[] buffer = new byte[1024];
			int len = 0;
			try {
				while ((len = in.read(buffer)) > 0 && alive) {
					for (StreamListener listener : streamListeners) {
						listener.hasRead(buffer, len);
					}
					lookForMatch(buffer, len);
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		synchronized void lookForMatch(byte[] s, int length) {
			for(int i = 0; alive && i < length; i++) {
				lastLine.append((char)s[i]);
				for (int m = 0; alive && waitFor != null && m < waitFor.length; m++) {
					if(s[i] == waitFor[m].charAt(matchPos[m])) {
						// the whole thing matched so, return the match answer
						// and reset to use the next match
						if(++matchPos[m] >= waitFor[m].length()) {
							lastMatched = m;
							this.notifyAll();
							reset();
						}
						
					} else {
						// if the current character did not match reset
						matchPos[m] = 0;
						if (s[i] == '\n') {
							lastLine.setLength(0);
						}
					}
				}
				 
		    }
		}
		
		synchronized void reset() {
			waitFor = null;
			matchPos = null;
		}

	}

	public void disconnect() {
		dumper.stop();
		sess.close();
		
		sess = null;
		dumper = null;
		dumperThread = null;
		out = null;
	}

}
